#include <bits/stdc++.h> 
class DisjointSet {
    public:
    vector<int> parent, size;
    DisjointSet (int n) {
        parent.resize(n+1, 0);
        size.resize(n+1, 1);
        for(int i=0;i<=n;i++) {
            parent[i] = i;
        }
    }

    int findUpar(int node) {
        if(parent[node] == node) return node;
        return parent[node] = findUpar(parent[node]);
    }

    void Union(int u, int v) {
        int ulp_u = findUpar(u);
        int ulp_v = findUpar(v);
        if(ulp_u == ulp_v) return;
        if(size[ulp_u] >= size[ulp_v]) {
            parent[ulp_v] = ulp_u;
            size[ulp_u] += size[ulp_v];
        }
        else {
            parent[ulp_u] = ulp_v;
            size[ulp_v] += size[ulp_u];
        }
    }
};
void dfs(int ind, vector<string> &sentence, vector<vector<string>> &ans, map<int, set<string>>& mp, 
unordered_map<string,int> &wordToIndex, DisjointSet &ds) {

	if(ind == sentence.size()) {
		ans.push_back(sentence);
		return;
	}

	if(wordToIndex.find(sentence[ind]) != wordToIndex.end()) {
		int i = wordToIndex[sentence[ind]];
		for(auto word: mp[ds.findUpar(i)]) {
			string original = sentence[ind];
			sentence[ind] = word;
			dfs(ind+1, sentence, ans, mp, wordToIndex, ds);
			sentence[ind] = original;
		}
	}
	else dfs(ind+1, sentence, ans, mp, wordToIndex, ds);
}
vector<vector<string>> findSentences(vector<vector<string>>& synonyms, vector<string>& sentence) {

	unordered_map<string,int> wordToIndex;
	int ind = 0;
	for(auto it: synonyms) {
		string w1 = it[0], w2 = it[1];
		if(wordToIndex.find(w1) == wordToIndex.end()) {
			wordToIndex[w1] = ind;
			ind++;
		}
		if(wordToIndex.find(w2) == wordToIndex.end()) {
			wordToIndex[w2] = ind;
			ind++;
		}
	}

	int n = wordToIndex.size();

	DisjointSet ds(n);
	for(auto it: synonyms) {
		string w1 = it[0], w2 = it[1];
		int i1 = wordToIndex[w1], i2 = wordToIndex[w2];
		ds.Union(i1, i2);
	}

	map<int, set<string>> mp;
	for(auto it: synonyms) {
		string w1 = it[0], w2 = it[1];
		int i1 = wordToIndex[w1], i2 = wordToIndex[w2];
		int parnode = ds.findUpar(i1);
		mp[parnode].insert(w1);
		mp[parnode].insert(w2);
	}

	vector<vector<string>> ans;
	dfs(0, sentence, ans, mp, wordToIndex, ds);
	return ans;
}
