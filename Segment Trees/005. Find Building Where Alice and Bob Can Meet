class ST {
    vector<int> tree;
    vector<int> arr;
    int n;

    void build(int ind, int low, int high) {
        if(low == high) {
            tree[ind] = low;
            return;
        }
        int mid = low+(high-low)/2;
        build(2*ind+1, low, mid);
        build(2*ind+2, mid+1, high);
        tree[ind] = (arr[tree[2*ind+1]] >= arr[tree[2*ind+2]]) ? tree[2*ind+1] : tree[2*ind+2];
    }

    int query(int ind, int low, int high, int l, int r) {
        if (high < l || r < low) return -1;
		if (low >= l && high <= r) return tree[ind];


		int mid = low + (high - low) / 2;
		int left = query(2 * ind + 1, low, mid, l, r);
		int right = query(2 * ind + 2, mid + 1, high, l, r);
        if(left == -1) return right;
        if(right == -1) return left;
        if(arr[left] >= arr[right]) return left;
        return right;
    }
public:
    ST(vector<int> &input) {
        n = input.size();
        arr = input;
        tree.resize(4 * n);
        build(0, 0, n-1);
    }

    int getMaxInd(int l, int r) {
        return query(0, 0, n-1, l, r);
    }
};
class Solution {
    bool isPossible(int l, int r, int a, int b, vector<int> &heights, ST &st) {
        int maxInd = st.getMaxInd(l, r);
        if(heights[maxInd] > heights[a] && heights[maxInd] > heights[b]) return true;
        return false;
    }
public:
    vector<int> leftmostBuildingQueries(vector<int>& heights, vector<vector<int>>& queries) {
        
        ST st(heights);

        int n = heights.size();
        vector<int> res;

        for(auto q: queries) {
            int l = q[0], r = q[1];
            if(l > r) swap(l, r);

            if(l == r || heights[l] < heights[r]) {
                res.push_back(r);
                continue;
            }

            int ans = -1;
            int low = r+1, high = n-1;
            while(low <= high) {
                int mid = low + (high-low) / 2;
                if(isPossible(low, mid, l, r, heights, st)){
                    ans = mid;
                    high = mid-1;
                }
                else low = mid+1;
            } 
            res.push_back(ans);
        }

        return res;
    }
};
